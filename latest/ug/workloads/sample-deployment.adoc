//!!NODE_ROOT <section>


[.topic]
[[sample-deployment,sample-deployment.title]]
= Deploy a sample application on Linux
:info_doctype: section
:info_title: Deploy a sample application on Linux
:info_titleabbrev: Sample application deployment (Linux)

include::../attributes.txt[]

In this topic, you deploy a sample application to your cluster on linux nodes.

== Prerequisites

* An existing [.noloc]`Kubernetes` cluster with at least one node. If you don't have an existing Amazon EKS cluster, you can deploy one using one of the guides in <<getting-started>>. 
* `Kubectl` installed on your computer. For more information, see <<install-kubectl>>.
* `Kubectl` configured to communicate with your cluster. For more information, see <<create-kubeconfig>>.
* If you plan to deploy your sample workload to Fargate, then you must have an existing <<fargate-profile,Fargate profile>> that includes the same namespace created in this tutorial, which is `eks-sample-app`, unless you change the name. If you created a cluster with one of the gudes in <<getting-started>>, then you'll have to create a new profile, or add the namespace to your existing profile, because the profile created in the getting started guides doesn't specify the namespace used in this tutorial. Your VPC must also have at least one private subnet.

Though many variables are changeable in the following steps, we recommend only changing variable values where specified. Once you have a better understanding of [.noloc]`Kubernetes` [.noloc]`Pods`, deployments, and services, you can experiment with changing other values.

== Create a namespace

A namespace allows you to group resources in [.noloc]`Kubernetes`. For more information, see https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/[Namespaces] in the [.noloc]`Kubernetes` documentation. If you plan to deploy your sample application to  <<fargate,Simplify compute management with {aws} Fargate>>, make sure that the value for `namespace` in your <<fargate-profile,Define which Pods use {aws} Fargate when launched>> is `eks-sample-app`.

[source,bash,subs="verbatim,attributes,quotes"]
----
kubectl create namespace eks-sample-app
----

== Create a Kubernetes deployment

Create a [.noloc]`Kubernetes` deployment. This sample deployment pulls a container image from a public repository and deploys three replicas (individual [.noloc]`Pods`) of it to your cluster. To learn more, see https://kubernetes.io/docs/concepts/workloads/controllers/deployment/[Deployments] in the [.noloc]`Kubernetes` documentation.

. Save the following contents to a file named `eks-sample-deployment.yaml`. The containers in the sample application don't use network storage, but you might have applications that need to. For more information, see <<storage>>.
+
** The `amd64` or `arm64` `values` under the `kubernetes.io/arch` key mean that the application can be deployed to either hardware architecture (if you have both in your cluster). This is possible because this image is a multi-architecture image, but not all are. You can determine the hardware architecture that the image is supported on by viewing the https://gallery.ecr.aws/nginx/nginx[image details] in the repository that you're pulling it from. When deploying images that don't support a hardware architecture type, or that you don't want the image deployed to, remove that type from the manifest. For more information, see https://kubernetes.io/docs/reference/labels-annotations-taints/[Well-Known Labels, Annotations and Taints] in the [.noloc]`Kubernetes` documentation.
** The `kubernetes.io/os: linux` `nodeSelector` means that if you had [.noloc]`Linux` and [.noloc]`Windows` nodes (for example) in your cluster, the image would only be deployed to [.noloc]`Linux` nodes. For more information, see https://kubernetes.io/docs/reference/labels-annotations-taints/[Well-Known Labels, Annotations and Taints] in the [.noloc]`Kubernetes` documentation.
+
[source,yaml,subs="verbatim,attributes,quotes"]
----
apiVersion: apps/v1
kind: Deployment
metadata:
  name: eks-sample-linux-deployment
  namespace: eks-sample-app
  labels:
    app: eks-sample-linux-app
spec:
  replicas: 3
  selector:
    matchLabels:
      app: eks-sample-linux-app
  template:
    metadata:
      labels:
        app: eks-sample-linux-app
    spec:
      affinity:
        nodeAffinity:
          requiredDuringSchedulingIgnoredDuringExecution:
            nodeSelectorTerms:
            - matchExpressions:
              - key: kubernetes.io/arch
                operator: In
                values:
                - amd64
                - arm64
      containers:
      - name: nginx
        image: public.ecr.aws/nginx/nginx:1.23
        ports:
        - name: http
          containerPort: 80
        imagePullPolicy: IfNotPresent
      nodeSelector:
        kubernetes.io/os: linux
----
+
. Apply the deployment manifest to your cluster.
+
[source,bash,subs="verbatim,attributes,quotes"]
----
kubectl apply -f eks-sample-deployment.yaml
----

== Create a service

A service allows you to access all replicas through a single IP address or name. For more information, see https://kubernetes.io/docs/concepts/services-networking/service/[Service] in the [.noloc]`Kubernetes` documentation. Though not implemented in the sample application, if you have applications that need to interact with other {aws} services, we recommend that you create [.noloc]`Kubernetes` service accounts for your [.noloc]`Pods`, and associate them to {aws} IAM accounts. By specifying service accounts, your [.noloc]`Pods` have only the minimum permissions that you specify for them to interact with other services. For more information, see <<iam-roles-for-service-accounts>>.

. Save the following contents to a file named `eks-sample-service.yaml`. [.noloc]`Kubernetes` assigns the service its own IP address that is accessible only from within the cluster. To access the service from outside of your cluster, deploy the  <<aws-load-balancer-controller,{aws} Load Balancer Controller>> to load balance <<alb-ingress,application>> or <<network-load-balancing,network>> traffic to the service. 
+
[source,yaml,subs="verbatim,attributes,quotes"]
----
apiVersion: v1
kind: Service
metadata:
  name: eks-sample-linux-service
  namespace: eks-sample-app
  labels:
    app: eks-sample-linux-app
spec:
  selector:
    app: eks-sample-linux-app
  ports:
    - protocol: TCP
      port: 80
      targetPort: 80
----
. Apply the service manifest to your cluster.
+
[source,bash,subs="verbatim,attributes,quotes"]
----
kubectl apply -f eks-sample-service.yaml
----

[[sample-app-view-namespace,sample-app-view-namespace.title]]
== Review resources created

. View all resources that exist in the `eks-sample-app` namespace.
+
[source,bash,subs="verbatim,attributes,quotes"]
----
kubectl get all -n eks-sample-app
----
+
An example output is as follows.
+
[source,bash,subs="verbatim,attributes,quotes"]
----
NAME                                               READY   STATUS    RESTARTS   AGE
pod/eks-sample-linux-deployment-65b7669776-m6qxz   1/1     Running   0          27m
pod/eks-sample-linux-deployment-65b7669776-mmxvd   1/1     Running   0          27m
pod/eks-sample-linux-deployment-65b7669776-qzn22   1/1     Running   0          27m

NAME                               TYPE         CLUSTER-IP      EXTERNAL-IP   PORT(S)   AGE
service/eks-sample-linux-service   ClusterIP    10.100.74.8     <none>        80/TCP    32m

NAME                                        READY   UP-TO-DATE   AVAILABLE   AGE
deployment.apps/eks-sample-linux-deployment 3/3     3            3           27m

NAME                                                      DESIRED   CURRENT   READY   AGE
replicaset.apps/eks-sample-linux-deployment-776d8f8fd8    3         3         3       27m
----
+
In the output, you see the service and deployment that were specified in the sample manifests deployed in previous steps. You also see three [.noloc]`Pods`. This is because `3` `replicas` were specified in the sample manifest. For more information about [.noloc]`Pods`, see https://kubernetes.io/docs/concepts/workloads/pods/pod/[Pods] in the [.noloc]`Kubernetes` documentation. [.noloc]`Kubernetes` automatically creates the `replicaset` resource, even though it isn't specified in the sample manifests. For more information about `ReplicaSets`, see https://kubernetes.io/docs/concepts/workloads/controllers/replicaset/[ReplicaSet] in the [.noloc]`Kubernetes` documentation.
+
NOTE: [.noloc]`Kubernetes` maintains the number of replicas that are specified in the manifest. If this were a production deployment and you wanted [.noloc]`Kubernetes` to horizontally scale the number of replicas or vertically scale the compute resources for the [.noloc]`Pods`, use the  <<horizontal-pod-autoscaler,Scale pod deployments with Horizontal Pod Autoscaler>> and the <<vertical-pod-autoscaler,Adjust pod resources with Vertical Pod Autoscaler>> to do so.
. View the details of the deployed service.
+
[source,bash,subs="verbatim,attributes,quotes"]
----
kubectl -n eks-sample-app describe service eks-sample-linux-service
----
+
An example output is as follows.
+
[source,bash,subs="verbatim,attributes,quotes"]
----
Name:              eks-sample-linux-service
Namespace:         eks-sample-app
Labels:            app=eks-sample-linux-app
Annotations:       <none>
Selector:          app=eks-sample-linux-app
Type:              ClusterIP
IP Families:       <none>
IP:                10.100.74.8
IPs:               10.100.74.8
Port:              <unset>  80/TCP
TargetPort:        80/TCP
Endpoints:         192.168.24.212:80,192.168.50.185:80,192.168.63.93:80
Session Affinity:  None
Events:            <none>
----
+
In the previous output, the value for `IP:` is a unique IP address that can be reached from any node or [.noloc]`Pod` within the cluster, but it can't be reached from outside of the cluster. The values for `Endpoints` are IP addresses assigned from within your VPC to the [.noloc]`Pods` that are part of the service.
. View the details of one of the [.noloc]`Pods` listed in the output when you  <<sample-app-view-namespace,viewed the namespace>> in a previous step. Replace [.replaceable]`776d8f8fd8-78w66` with the value returned for one of your [.noloc]`Pods`.
+
[source,bash,subs="verbatim,attributes,quotes"]
----
kubectl -n eks-sample-app describe pod eks-sample-linux-deployment-65b7669776-m6qxz
----
+
Abbreviated example output
+
[source,bash,subs="verbatim,attributes,quotes"]
----
Name:         eks-sample-linux-deployment-65b7669776-m6qxz
Namespace:    eks-sample-app
Priority:     0
Node:         ip-192-168-45-132.us-west-2.compute.internal/192.168.45.132
[...]
IP:           192.168.63.93
IPs:
  IP:           192.168.63.93
Controlled By:  ReplicaSet/eks-sample-linux-deployment-65b7669776
[...]
Conditions:
  Type              Status
  Initialized       True
  Ready             True
  ContainersReady   True
  PodScheduled      True
[...]
Events:
  Type    Reason     Age    From                                                 Message
  ----    ------     ----   ----                                                 -------
  Normal  Scheduled  3m20s  default-scheduler                                    Successfully assigned eks-sample-app/eks-sample-linux-deployment-65b7669776-m6qxz to ip-192-168-45-132.us-west-2.compute.internal
[...]
----
+
In the previous output, the value for `IP:` is a unique IP that's assigned to the [.noloc]`Pod` from the CIDR block assigned to the subnet that the node is in. If you prefer to assign [.noloc]`Pods` IP addresses from different CIDR blocks, you can change the default behavior. For more information, see <<cni-custom-network>>. You can also see that the [.noloc]`Kubernetes` scheduler scheduled the [.noloc]`Pod` on the `Node` with the IP address [.replaceable]`192.168.45.132`.
+
TIP: Rather than using the command line, you can view many details about [.noloc]`Pods`, services, deployments, and other [.noloc]`Kubernetes` resources in the {aws-management-console}. For more information, see <<view-kubernetes-resources>>.

== Run a shell on a Pod

. Run a shell on the [.noloc]`Pod` that you described in the previous step, replacing [.replaceable]`65b7669776-m6qxz` with the ID of one of your [.noloc]`Pods`.
+
[source,bash,subs="verbatim,attributes,quotes"]
----
kubectl exec -it eks-sample-linux-deployment-65b7669776-m6qxz -n eks-sample-app -- /bin/bash
----
. From the [.noloc]`Pod` shell, view the output from the web server that was installed with your deployment in a previous step. You only need to specify the service name. It is resolved to the service's IP address by [.noloc]`CoreDNS`, which is deployed with an Amazon EKS cluster, by default.
+
[source,bash,subs="verbatim,attributes,quotes"]
----
curl eks-sample-linux-service
----
+
An example output is as follows.
+
[source,bash,subs="verbatim,attributes,quotes"]
----
<!DOCTYPE html>
<html>
<head>
<title>Welcome to nginx!</title>
[...]
----
. From the [.noloc]`Pod` shell, view the DNS server for the [.noloc]`Pod`.
+
[source,bash,subs="verbatim,attributes,quotes"]
----
cat /etc/resolv.conf
----
+
An example output is as follows.
+
[source,bash,subs="verbatim,attributes,quotes"]
----
nameserver 10.100.0.10
search eks-sample-app.svc.cluster.local svc.cluster.local cluster.local us-west-2.compute.internal
options ndots:5
----
+
In the previous output, `10.100.0.10` is automatically assigned as the `nameserver` for all [.noloc]`Pods` deployed to the cluster.
. Disconnect from the [.noloc]`Pod` by typing `exit`.
. Once you're finished with the sample application, you can remove the sample namespace, service, and deployment with the following command.
+
[source,bash,subs="verbatim,attributes,quotes"]
----
kubectl delete namespace eks-sample-app
----


[[sample-deployment-next-steps,sample-deployment-next-steps.title]]
== Next Steps

After you deploy the sample application, you might want to try some of the following exercises:



* <<alb-ingress,Route application and HTTP traffic with Application Load Balancers>>
* <<network-load-balancing,Route TCP and UDP traffic with Network Load Balancers>>
